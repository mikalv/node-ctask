// Generated by CoffeeScript 1.4.0
var Job, Scheduler, cluster, trace;

cluster = require('cluster');

trace = console.log;

Scheduler = {
  jobs: {},
  workers: [],
  employed: {},
  timers: {},
  locked: false,
  attach: function(job, reattach) {
    var _this = this;
    if (this.jobs[job.name]) {
      throw new Error("Job \"" + job.name + "\" already exist!");
      return job;
    }
    this.jobs[job.name] = job;
    if (job.shared) {
      if (cluster.isMaster) {
        if (!this.workers.length) {
          if (job.report) {
            trace("[job] no workers for shared jobs");
          }
        }
        job._interval = setInterval(function() {
          var worker;
          if (job.running && !job.multi) {
            return;
          }
          if (_this.locked || job.locked || !job.enabled) {
            return;
          }
          if (_this.workers.length) {
            worker = _this.workers.shift();
            _this.employed[worker.id] = worker;
            _this.timers[worker.id] = new Date().getTime();
            if (job.report) {
              trace("[job] starting \"" + job.name + "\" by worker " + worker.id);
            }
            job.running = true;
            if (job.locking) {
              job.locked = true;
            }
            return worker.send({
              _node_scheduler: {
                action: 'trigger',
                job: job.name
              }
            });
          }
        }, job.interval);
      }
    } else {
      if (!cluster.isWorker) {
        job._interval = setInterval(function() {
          var start, _ref, _ref1;
          if (job.running && !job.multi) {
            return;
          }
          if (_this.locked || job.locked || !job.enabled) {
            return;
          }
          if (job.report) {
            trace("[job] starting \"" + job.name + "\"");
          }
          job.running = true;
          if (job.locking) {
            job.locked = true;
          }
          start = new Date().getTime();
          return (_ref = job.action) != null ? _ref.call((_ref1 = job.context) != null ? _ref1 : _this, job, function(err) {
            if (job.report) {
              trace("[job] \"" + job.name + "\" completed in " + (new Date().getTime() - start) + "ms");
            }
            return _this._complete(err, job);
          }) : void 0;
        }, job.interval);
      }
    }
    if (job.report && !reattach) {
      trace("[job] \"" + job.name + "\" attached");
    }
    return job;
  },
  detach: function(job) {
    if (!this.jobs[job.name]) {
      return false;
    }
    if (job.running) {
      job.detachWhenPossible = true;
      return true;
    }
    delete this.jobs[job.name];
    clearInterval(job._interval);
    job._interval = null;
    if (job.report) {
      trace("[job] \"" + job.name + "\" detached");
    }
    return job;
  },
  _complete: function(err, job) {
    job.running = false;
    job.locked = false;
    if (job.report && err) {
      trace("[job] \"" + job.name + "\" finshed with error: " + err);
    }
    if (job.detachWhenPossible) {
      delete job.detachWhenPossible;
      return this.detach(job);
    }
  },
  _init: function() {
    var handler, id, worker, _fn, _ref,
      _this = this;
    handler = function(msg, worker) {
      var job;
      if (msg != null ? msg._node_scheduler : void 0) {
        job = _this.jobs[msg._node_scheduler.job];
        switch (msg._node_scheduler.action) {
          case 'complete':
            if (job.report) {
              trace("[job] \"" + job.name + "\" completed by worker " + worker.id + " in " + (new Date().getTime() - _this.timers[worker.id]) + "ms");
            }
            delete _this.timers[worker.id];
            delete _this.employed[worker.id];
            _this.workers.push(worker);
            return _this._complete(msg._node_scheduler.error, job);
          case 'unlock':
            if (job.report) {
              trace("[job] \"" + job.name + "\" unlocked by worker " + worker.id);
            }
            return job.locked = false;
        }
      }
    };
    if (cluster.isMaster) {
      _ref = cluster.workers;
      _fn = function(worker) {
        _this.workers.push(worker);
        return worker.on('message', function(msg) {
          return handler.call(_this, msg, worker);
        });
      };
      for (id in _ref) {
        worker = _ref[id];
        _fn(worker);
      }
      cluster.on('fork', function(worker) {
        _this.workers.push(worker);
        return worker.on('message', function(msg) {
          return handler.call(_this, msg, worker);
        });
      });
      cluster.on('exit', function(worker) {
        return _this.workers.splice(_this.workers.indexOf(worker), 1);
      });
    }
    if (cluster.isWorker) {
      return process.on('message', function(msg) {
        if (msg != null ? msg._node_scheduler : void 0) {
          switch (msg._node_scheduler.action) {
            case 'trigger':
              return _this._trigger(msg._node_scheduler.job);
          }
        }
      });
    }
  },
  _trigger: function(jobname) {
    var job, _ref, _ref1,
      _this = this;
    job = this.jobs[jobname];
    if (!job) {
      return process.send({
        _node_scheduler: {
          action: 'complete',
          job: jobname,
          error: "Job not found on worker " + cluster.worker.id
        }
      });
    } else {
      return (_ref = job.action) != null ? _ref.call((_ref1 = job.context) != null ? _ref1 : this, job, function(err) {
        return process.send({
          _node_scheduler: {
            action: 'complete',
            job: job.name,
            error: err
          }
        });
      }) : void 0;
    }
  }
};

Scheduler._init();

Job = (function() {

  Job.prototype.shared = false;

  Job.prototype.report = false;

  Job.prototype.multi = false;

  Job.prototype.action = null;

  Job.prototype.locking = false;

  Job.prototype.enabled = true;

  function Job(cfg) {
    var i;
    for (i in cfg) {
      this[i] = cfg[i];
    }
  }

  Job.prototype.start = function() {
    return Scheduler.attach(this);
  };

  Job.prototype.stop = function() {
    return Scheduler.detach(this);
  };

  Job.prototype.lock = function() {
    if (this.shared && cluster.isWorker) {
      return process.send({
        _node_scheduler: {
          action: 'lock',
          job: this.name
        }
      });
    } else {
      return this.locked = true;
    }
  };

  Job.prototype.unlock = function() {
    if (this.shared && cluster.isWorker) {
      return process.send({
        _node_scheduler: {
          action: 'unlock',
          job: this.name
        }
      });
    } else {
      return this.locked = false;
    }
  };

  return Job;

})();

module.exports.Scheduler = Scheduler;

module.exports.Job = Job;
