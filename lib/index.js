// Generated by CoffeeScript 1.4.0
var EventEmitter, Job, Scheduler, cluster,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

cluster = require('cluster');

EventEmitter = require('events').EventEmitter;

Scheduler = (function(_super) {

  __extends(Scheduler, _super);

  Scheduler.prototype.jobs = {};

  Scheduler.prototype.workers = [];

  Scheduler.prototype.employed = {};

  Scheduler.prototype.timers = {};

  Scheduler.prototype.locked = false;

  function Scheduler() {
    var handler, id, worker, _fn, _ref,
      _this = this;
    handler = function(msg, worker) {
      var job;
      if (msg != null ? msg._node_scheduler : void 0) {
        job = _this.jobs[msg._node_scheduler.job];
        switch (msg._node_scheduler.action) {
          case 'complete':
            _this._status("Job \"" + job.name + "\" completed by worker " + worker.id + " in " + (new Date().getTime() - _this.timers[worker.id]) + "ms");
            delete _this.timers[worker.id];
            delete _this.employed[worker.id];
            _this.workers.push(worker);
            return _this._complete(msg._node_scheduler.error, job);
          case 'unlock':
            _this._status("Job \"" + job.name + "\" unlocked by worker " + worker.id);
            return job.locked = false;
        }
      }
    };
    if (cluster.isMaster) {
      _ref = cluster.workers;
      _fn = function(worker) {
        _this.workers.push(worker);
        return worker.on('message', function(msg) {
          return handler.call(_this, msg, worker);
        });
      };
      for (id in _ref) {
        worker = _ref[id];
        _fn(worker);
      }
      cluster.on('fork', function(worker) {
        _this.workers.push(worker);
        return worker.on('message', function(msg) {
          return handler.call(_this, msg, worker);
        });
      });
      cluster.on('exit', function(worker) {
        return _this.workers.splice(_this.workers.indexOf(worker), 1);
      });
    }
    if (cluster.isWorker) {
      process.on('message', function(msg) {
        if (msg != null ? msg._node_scheduler : void 0) {
          switch (msg._node_scheduler.action) {
            case 'trigger':
              return _this._trigger(msg._node_scheduler.job);
          }
        }
      });
    }
  }

  Scheduler.prototype.attach = function(job) {
    var _this = this;
    if (this.jobs[job.name]) {
      this._error("Job \"" + job.name + "\" already exist!");
      return job;
    }
    this.jobs[job.name] = job;
    if (job.shared) {
      if (cluster.isMaster) {
        if (!this.workers.length) {
          this._status("No workers for shared jobs");
        }
        job._interval = setInterval(function() {
          var worker;
          if (job.running && !job.multi) {
            return;
          }
          if (_this.locked || job.locked || !job.enabled) {
            return;
          }
          if (_this.workers.length) {
            worker = _this.workers.shift();
            _this.employed[worker.id] = worker;
            _this.timers[worker.id] = new Date().getTime();
            _this._status("Job starting \"" + job.name + "\" by worker " + worker.id);
            job.running = true;
            if (job.locking) {
              job.locked = true;
            }
            return worker.send({
              _node_scheduler: {
                action: 'trigger',
                job: job.name
              }
            });
          }
        }, job.interval);
      }
    } else {
      if (!cluster.isWorker) {
        job._interval = setInterval(function() {
          var start, _ref, _ref1;
          if (job.running && !job.multi) {
            return;
          }
          if (_this.locked || job.locked || !job.enabled) {
            return;
          }
          _this._status("Starting job \"" + job.name + "\"");
          job.running = true;
          if (job.locking) {
            job.locked = true;
          }
          start = new Date().getTime();
          return (_ref = job.action) != null ? _ref.call((_ref1 = job.context) != null ? _ref1 : _this, job, function(err) {
            _this._status("Job \"" + job.name + "\" completed in " + (new Date().getTime() - start) + "ms");
            return _this._complete(err, job);
          }) : void 0;
        }, job.interval);
      }
    }
    this._status("Job \"" + job.name + "\" attached");
    return job;
  };

  Scheduler.prototype.detach = function(job) {
    if (!this.jobs[job.name]) {
      return false;
    }
    if (job.running) {
      job.detachWhenPossible = true;
      return true;
    }
    delete this.jobs[job.name];
    clearInterval(job._interval);
    job._interval = null;
    this._status("Job \"" + job.name + "\" detached");
    return job;
  };

  Scheduler.prototype._complete = function(err, job) {
    job.running = false;
    job.locked = false;
    if (err) {
      this._error("Job \"" + job.name + "\" finshed with error: " + err);
    }
    if (job.detachWhenPossible) {
      delete job.detachWhenPossible;
      return this.detach(job);
    }
  };

  Scheduler.prototype._trigger = function(jobname) {
    var job, _ref, _ref1,
      _this = this;
    job = this.jobs[jobname];
    if (!job) {
      return process.send({
        _node_scheduler: {
          action: 'complete',
          job: jobname,
          error: "Job not found on worker " + cluster.worker.id
        }
      });
    } else {
      return (_ref = job.action) != null ? _ref.call((_ref1 = job.context) != null ? _ref1 : this, job, function(err) {
        return process.send({
          _node_scheduler: {
            action: 'complete',
            job: job.name,
            error: err
          }
        });
      }) : void 0;
    }
  };

  Scheduler.prototype._status = function(msg) {
    return this.emit('status', msg);
  };

  Scheduler.prototype._error = function(msg) {
    return this.emit('error', msg);
  };

  return Scheduler;

})(EventEmitter);

Job = (function() {

  Job.prototype.shared = false;

  Job.prototype.multi = false;

  Job.prototype.action = null;

  Job.prototype.locking = false;

  Job.prototype.enabled = true;

  function Job(cfg) {
    var i;
    for (i in cfg) {
      this[i] = cfg[i];
    }
  }

  Job.prototype.start = function() {
    return module.exports.Scheduler.attach(this);
  };

  Job.prototype.stop = function() {
    return module.exports.Scheduler.detach(this);
  };

  Job.prototype.lock = function() {
    if (this.shared && cluster.isWorker) {
      return process.send({
        _node_scheduler: {
          action: 'lock',
          job: this.name
        }
      });
    } else {
      return this.locked = true;
    }
  };

  Job.prototype.unlock = function() {
    if (this.shared && cluster.isWorker) {
      return process.send({
        _node_scheduler: {
          action: 'unlock',
          job: this.name
        }
      });
    } else {
      return this.locked = false;
    }
  };

  return Job;

})();

module.exports.Scheduler = new Scheduler;

module.exports.Job = Job;
